<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design and Analysis of Algorithms - Home</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            height: 100%;
            font-family: 'Arial', sans-serif;
            background-color: #f4f7fa; /* Light background color */
        }

        /* Navigation Bar Styling */
        nav {
            background-color: #003366; /* Dark Blue */
            position: fixed;
            top: 0;
            width: 100%;
            padding: 15px;
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        nav ul {
            list-style: none;
            display: flex;
            justify-content: center;
        }

        nav ul li {
            margin: 0 25px;
        }

        nav ul li a {
            text-decoration: none;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            transition: color 0.3s ease;
        }

        nav ul li a:hover {
            color: #ff7f50; /* Coral color for hover */
        }

        /* Main Container Styling */
        .container {
            position: relative;
            height: 100%;
            padding-top: 80px; /* Adjusted for fixed nav */
            background: url('image.png') no-repeat center center fixed; /* Corrected the path to the image */
            background-size: cover;
            background-color: rgba(0, 0, 0, 0.5); /* Overlay for readability */
        }

        .content {
            position: absolute;
            top: 30%;
            left: 10%;
            transform: translate(-10%, -30%);
            color: #fff;
            z-index: 1;
            padding: 20px;
            text-align: left;
        }

        h1 {
            font-size: 3.5rem;
            color: #ff7f50; /* Vibrant orange for visibility */
            margin-bottom: 20px;
            text-shadow: 3px 3px 10px rgba(0, 0, 0, 0.5);
        }

        p {
            font-size: 1.2rem;
            color: #f1f1f1;
            line-height: 1.8;
            margin: 20px 0;
        }

        .cta-button {
            background-color: #ff7f50;
            padding: 12px 20px;
            font-size: 1.2rem;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }

        .cta-button:hover {
            background-color: #e06f35; /* Slightly darker orange */
        }

        /* Main Content Area Styling */
        .course-info {
            padding: 40px 15%;
            text-align: center;
            background-color: #fff;
            color: #003366;
            box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.1);
        }

        .course-info h2 {
            font-size: 2.5rem;
            color: #003366;
        }

        .course-info p {
            font-size: 1.1rem;
            margin-bottom: 15px;
            line-height: 1.7;
        }

        .footer {
            background-color: #003366;
            color: #fff;
            text-align: center;
            padding: 15px;
            position: fixed;
            bottom: 0;
            width: 100%;
        }
    </style>
</head>
<body>

    <!-- Navigation Bar -->
    <nav>
        <ul>
            <li><a href="#home">Home</a></li>
            <li><a href="#project-overview">Project Overview</a></li>
            <li><a href="#business-cases">Business Cases</a></li>
            <li><a href="#reflections">Reflections</a></li>
        </ul>
    </nav>

    <!-- Main Container with Background Image -->
    <div id="home" class="container">
        <div class="content">
            <h1>Welcome to the Design and Analysis of Algorithms Course</h1>
            <p>Master the art of algorithm design and analysis to solve complex, real-world problems efficiently.</p>
            <a href="#course-info" class="cta-button">Explore the Course</a>
        </div>
    </div>

    <!-- Course Information Section -->
    <div id="course-info" class="course-info">
        <h2>What is the Course About?</h2>
        <p>Our course, Design and Analysis of Algorithms, introduces us to the fundamentals of algorithms and data structures, focusing on their design, analysis, and application.</p>
        <p>We start with core concepts like time and space complexities, recursion, and backtracking. Next, we delve into tools like hashing and Union-Find, along with advanced data structures such as AVL Trees, Segment Trees, and Red-Black Trees. Sorting and searching algorithms, including Quick Sort, KMP, and Rabin-Karp, help us understand efficient data processing techniques.</p>
        <p>Graph algorithms like Dijkstra’s shortest path and Prim’s spanning tree, and case studies such as the Travelling Salesperson Problem, show us how algorithms solve complex, real-world problems. The course also introduces concepts like NP-completeness and the limitations of algorithmic power.</p>
        <p>By the end, we gain a strong foundation in computational thinking and the ability to develop efficient solutions to challenging problems.</p>
    </div>

    <!-- Detailed Course Data Section -->
    <div class="course-info">
        <h2>What Kind of Data Structures and Algorithms Have We Studied So Far?</h2>
        <p><strong>Math Basics:</strong> We started our journey by understanding basic concepts of mathematics fundamental to algorithm analysis, including time and space efficiency. We worked on problems like Tower of Brahma and the n-Queens Problem.</p>
        <p><strong>Math Foundations:</strong> We then explored the order of growth to understand solution efficiency more deeply.</p>
        <p><strong>Data Structure Management:</strong> We explored trees, including binary trees, AVL Trees, Red-Black Trees, and data structures like heaps, tries, and skip lists. Key algorithms covered included BFS and DFS.</p>
        <p><strong>Sorting Algorithms:</strong> We studied algorithms such as Bubble Sort, Quick Sort, Merge Sort, and Heap Sort, learning how to organize data efficiently.</p>
        <p><strong>Searching Algorithms:</strong> We learned techniques such as Linear Search, Binary Search, and string matching algorithms including KMP and Rabin-Karp.</p>
        <p><strong>Graph Algorithms:</strong> Algorithms like Depth-First Search, Dijkstra’s Algorithm, Bellman-Ford, Floyd-Warshall, and Prim’s and Kruskal’s MST Algorithms were explored in depth.</p>
        <p><strong>Linear Search:</strong> Linear Search is the simplest search algorithm. It works by checking each element of the list sequentially until the desired element is found or the list ends.</p>
<p><strong>Time Complexity:</strong> O(n), where n is the number of elements in the list.</p>
<p><strong>Use Cases:</strong> Suitable for small datasets or unsorted data.</p>

<p><strong>Binary Search:</strong> Binary Search is a much more efficient algorithm than Linear Search but requires the list to be sorted. It works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, it narrows the interval to the lower half. Otherwise, it narrows the interval to the upper half.</p>
<p><strong>Time Complexity:</strong> O(log n), where n is the number of elements in the sorted list.</p>
<p><strong>Use Cases:</strong> Effective for large sorted datasets, such as searching in sorted arrays or databases.</p>

<p><strong>KMP (Knuth-Morris-Pratt) Algorithm:</strong> The KMP algorithm is used for string matching. It improves the brute force search by using information gained from previous matches to skip unnecessary comparisons. The algorithm preprocesses the pattern and constructs a partial match table (also called the "prefix table") to avoid re-checking characters that have already been matched.</p>
<p><strong>Time Complexity:</strong> O(m + n), where m is the length of the pattern and n is the length of the text.</p>
<p><strong>Use Cases:</strong> Efficient for finding a substring within a longer string, commonly used in text editors and search engines.</p>

<p><strong>Rabin-Karp Algorithm:</strong> Rabin-Karp is another string matching algorithm that uses hashing to find a pattern in a text. It computes a hash value for the pattern and compares it to hash values of substrings of the text. If the hash values match, it performs a direct comparison of the characters to ensure they are the same.</p>
<p><strong>Time Complexity:</strong> O(m + n) on average, where m is the length of the pattern and n is the length of the text. However, in the worst case, it can be O(mn) if many hash collisions occur.</p>
<p><strong>Use Cases:</strong> Useful for finding multiple patterns in a text or searching for a pattern in a large dataset.</p>

<p><strong>Depth-First Search (DFS):</strong> DFS explores a graph by going as deep as possible down one path before backtracking. It starts from a source node and explores each branch before moving to the next branch.</p>
<p><strong>Time Complexity:</strong> O(V + E), where V is the number of vertices and E is the number of edges.</p>
<p><strong>Use Cases:</strong> Used in topological sorting, cycle detection, pathfinding, and maze-solving.</p>

<p><strong>Dijkstra’s Algorithm:</strong> Dijkstra's Algorithm finds the shortest path from a source vertex to all other vertices in a graph with non-negative edge weights. It uses a greedy approach and updates the shortest known distance to each vertex.</p>
<p><strong>Time Complexity:</strong> O(V^2) in the simplest form, but can be optimized to O(E + V log V) using a priority queue (min-heap).</p>
<p><strong>Use Cases:</strong> Used in routing and network optimization, such as in GPS navigation systems.</p>

<p><strong>Bellman-Ford Algorithm:</strong> The Bellman-Ford Algorithm is similar to Dijkstra's but can handle graphs with negative weight edges. It works by iteratively relaxing all edges and can also detect negative weight cycles.</p>
<p><strong>Time Complexity:</strong> O(VE), where V is the number of vertices and E is the number of edges.</p>
<p><strong>Use Cases:</strong> Useful for graphs with negative weight edges and detecting negative weight cycles.</p>

<p><strong>Floyd-Warshall Algorithm:</strong> Floyd-Warshall is an all-pairs shortest path algorithm that finds the shortest paths between all pairs of vertices in a weighted graph (can handle negative weights). It works by iteratively updating the shortest paths between pairs by considering each vertex as an intermediate vertex.</p>
<p><strong>Time Complexity:</strong> O(V^3), where V is the number of vertices.</p>
<p><strong>Use Cases:</strong> Suitable for applications needing the shortest paths between all pairs of nodes, like in network routing or social network analysis.</p>

<p><strong>Prim’s Algorithm:</strong> Prim's Algorithm is used to find the minimum spanning tree (MST) of a weighted, undirected graph. It starts from an arbitrary node and expands the MST by selecting the edge with the smallest weight that connects a vertex in the MST to a vertex outside the MST.</p>
<p><strong>Time Complexity:</strong> O(E log V), where E is the number of edges and V is the number of vertices.</p>
<p><strong>Use Cases:</strong> Used in network design, such as finding the most efficient way to connect nodes in a computer network.</p>

<p><strong>Kruskal’s Algorithm:</strong> Kruskal’s Algorithm is another method for finding the minimum spanning tree (MST) in a graph. Unlike Prim's, it works by sorting all the edges in the graph by weight and adding the smallest edge to the MST that doesn't form a cycle.</p>
<p><strong>Time Complexity:</strong> O(E log E), where E is the number of edges.</p>
<p><strong>Use Cases:</strong> Used in network design, such as constructing efficient electrical grids or minimizing road construction in geographical areas.</p>

    </div>

    <!-- Footer -->
    <div class="footer">
        <p>&copy; 2024 Design and Analysis of Algorithms. All rights reserved.</p>
    </div>

</body>
</html>
