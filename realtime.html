<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Disaster Response System</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1, h2 {
            color: #333;
        }
        p {
            font-size: 16px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: center;
        }
        .algorithms {
            margin-top: 30px;
        }
    </style>
</head>
<body>
    <h1>Real-Time Disaster Response System</h1>
    <p><strong>Goal:</strong> Reduce fatalities and ensure timely evacuation</p>
    <p><strong>SDG Goal:</strong> 11 - Sustainable Cities and Communities</p>
    <p><strong>Target:</strong> 11.5</p>
    <p><strong>Indicator:</strong> 11.5.1</p>
    <p><strong>Task:</strong> Create an early warning system for natural disasters, focusing on water-related disasters</p>

    <h2>Nodes</h2>
    <ul>
        <li><strong>Water Treatment Plants:</strong> W1, W2</li>
        <li><strong>Waste Disposal Sites:</strong> D1, D2</li>
        <li><strong>Residential Clusters:</strong> R1, R2, R3, R4</li>
    </ul>

    <h2>Distance Matrix (in km)</h2>
    <table>
        <thead>
            <tr>
                <th>From/To</th>
                <th>W1</th>
                <th>W2</th>
                <th>D1</th>
                <th>D2</th>
                <th>R1</th>
                <th>R2</th>
                <th>R3</th>
                <th>R4</th>
            </tr>
        </thead>
        <tbody>
            <tr><td>W1</td><td>0</td><td>10</td><td>15</td><td>18</td><td>8</td><td>12</td><td>20</td><td>25</td></tr>
            <tr><td>W2</td><td>10</td><td>0</td><td>12</td><td>15</td><td>10</td><td>15</td><td>22</td><td>18</td></tr>
            <tr><td>D1</td><td>15</td><td>12</td><td>0</td><td>8</td><td>10</td><td>18</td><td>25</td><td>22</td></tr>
            <tr><td>D2</td><td>18</td><td>15</td><td>8</td><td>0</td><td>15</td><td>20</td><td>28</td><td>25</td></tr>
            <tr><td>R1</td><td>8</td><td>10</td><td>10</td><td>15</td><td>0</td><td>5</td><td>12</td><td>18</td></tr>
            <tr><td>R2</td><td>12</td><td>15</td><td>18</td><td>20</td><td>5</td><td>0</td><td>8</td><td>10</td></tr>
            <tr><td>R3</td><td>20</td><td>22</td><td>25</td><td>28</td><td>12</td><td>8</td><td>0</td><td>5</td></tr>
            <tr><td>R4</td><td>25</td><td>18</td><td>22</td><td>25</td><td>18</td><td>10</td><td>5</td><td>0</td></tr>
        </tbody>
    </table>

    <h2 class="algorithms">Algorithms Used</h2>

    <h3>Dijkstraâ€™s Algorithm</h3>
    <p><strong>Purpose:</strong> Find the shortest path in a graph.</p>
    <p><strong>Application:</strong> Calculates optimal evacuation routes from residential clusters to safe zones.</p>

    <h3>A* Algorithm</h3>
    <p><strong>Purpose:</strong> Shortest path with a heuristic.</p>
    <p><strong>Application:</strong> Considers flood risks, road conditions, and traffic to find evacuation routes that avoid hazards.</p>

    <h3>Bellman-Ford Algorithm</h3>
    <p><strong>Purpose:</strong> Find shortest paths with negative edge weights.</p>
    <p><strong>Application:</strong> Handles scenarios with blocked or damaged routes (e.g., floods).</p>

    <h3>Flood Prediction Algorithms</h3>
    <p><strong>Purpose:</strong> Predict flood events using environmental data.</p>
    <p><strong>Application:</strong> Time-series forecasting (e.g., ARIMA, LSTM) to predict floods and identify high-risk areas.</p>

    <h3>Ant Colony Optimization (ACO)</h3>
    <p><strong>Purpose:</strong> Simulate ant behavior to find the shortest path.</p>
    <p><strong>Application:</strong> Identifies optimal evacuation routes and allocates resources like rescue teams efficiently.</p>

    <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bellman-Ford Algorithm Applications in Disaster Response</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        h2 {
            color: #34495e;
        }
        ul {
            list-style-type: square;
        }
        li {
            margin: 10px 0;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Key Applications of the Bellman-Ford Algorithm in Real-Time Disaster Response</h1>
        
        <h2>1. Blocked or Damaged Routes</h2>
        <p>Roads affected by floods or disasters can be marked with negative weights, helping to find alternate paths. This enables the identification of accessible routes when normal routes are blocked.</p>

        <h2>2. Dynamic Path Updates</h2>
        <p>Routes change during a disaster due to damage, floods, or infrastructure failures. The Bellman-Ford algorithm recalculates the shortest paths based on real-time data, ensuring the system adapts to the evolving situation.</p>

        <h2>3. Evacuation Optimization</h2>
        <p>Helps find the safest and quickest evacuation routes by considering damaged infrastructure, ensuring that people are routed away from danger zones efficiently.</p>

        <h2>4. Negative Weight Cycle Detection</h2>
        <p>The algorithm can detect critical failures, like infrastructure loops or areas experiencing repeated flooding, which require immediate attention for recovery and repair.</p>
    </div>
    <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bellman-Ford Algorithm</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #codeSection {
            display: none;
            white-space: pre-wrap;
            background-color: #f4f4f4;
            border: 1px solid #ccc;
            padding: 15px;
            margin-top: 20px;
            font-family: monospace;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007BFF;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>

<h1>Bellman-Ford Algorithm</h1>
<p>Click the button below to see the C++ code for the Bellman-Ford Algorithm.</p>

<button onclick="showCode()">Click here for Bellman-Ford Algorithm code</button>

<div id="codeSection">
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;string&gt;

using namespace std;

// Define a structure to represent an edge
struct Edge {
    int source, destination, weight;
};

// Bellman-Ford Algorithm to find the shortest paths from the source node
void bellmanFord(const vector&lt;Edge&gt;&amp; edges, int V, int E, int source) {
    // Step 1: Initialize distances from source to all other nodes as INFINITE
    vector&lt;int&gt; dist(V, INT_MAX);
    dist[source] = 0;

    // Step 2: Relax all edges V-1 times
    for (int i = 1; i &lt;= V - 1; ++i) {
        for (int j = 0; j &lt; E; ++j) {
            int u = edges[j].source;
            int v = edges[j].destination;
            int weight = edges[j].weight;
            if (dist[u] != INT_MAX &amp;&amp; dist[u] + weight &lt; dist[v]) {
                dist[v] = dist[u] + weight;
            }
        }
    }

    // Step 3: Check for negative-weight cycles
    for (int i = 0; i &lt; E; ++i) {
        int u = edges[i].source;
        int v = edges[i].destination;
        int weight = edges[i].weight;
        if (dist[u] != INT_MAX &amp;&amp; dist[u] + weight &lt; dist[v]) {
            cout &lt;&lt; "Negative weight cycle detected!" &lt;&lt; endl;
            return;
        }
    }

    // Step 4: Output the shortest distances from the source node
    cout &lt;&lt; "Shortest distances from source node " &lt;&lt; source &lt;&lt; " (Water Treatment Plants and other nodes):" &lt;&lt; endl;
    for (int i = 0; i &lt; V; ++i) {
        if (dist[i] == INT_MAX)
            cout &lt;&lt; "Node " &lt;&lt; i &lt;&lt; " is unreachable." &lt;&lt; endl;
        else
            cout &lt;&lt; "Node " &lt;&lt; i &lt;&lt; ": " &lt;&lt; dist[i] &lt;&lt; " km" &lt;&lt; endl;
    }
}

int main() {
    // Number of nodes (V) and edges (E)
    int V = 8;  // Number of nodes (e.g., W1, W2, D1, D2, R1, R2, R3, R4)
    int E = 20; // Number of edges (each edge between two nodes)

    // List of edges with (source, destination, weight)
    vector&lt;Edge&gt; edges = {
        {0, 1, 10}, {0, 2, 15}, {0, 3, 18}, {0, 4, 8}, {0, 5, 12}, {0, 6, 20}, {0, 7, 25}, {0, 8, 18},
        {1, 0, 10}, {1, 2, 12}, {1, 3, 15}, {1, 4, 10}, {1, 5, 15}, {1, 6, 22}, {1, 7, 18}, {1, 8, 10},
        {2, 0, 15}, {2, 1, 12}, {2, 3, 8}, {2, 4, 10}, {2, 5, 18}, {2, 6, 25}, {2, 7, 22}, {2, 8, 20},
        {3, 0, 18}, {3, 1, 15}, {3, 2, 8}, {3, 4, 15}, {3, 5, 20}, {3, 6, 28}, {3, 7, 25}, {3, 8, 30},
        {4, 0, 8}, {4, 1, 10}, {4, 2, 10}, {4, 3, 15}, {4, 5, 5}, {4, 6, 12}, {4, 7, 20}, {4, 8, 18},
        {5, 0, 12}, {5, 1, 15}, {5, 2, 18}, {5, 3, 20}, {5, 4, 5}, {5, 6, 10}, {5, 7, 15}, {5, 8, 18},
        {6, 0, 20}, {6, 1, 22}, {6, 2, 25}, {6, 3, 28}, {6, 4, 12}, {6, 5, 10}, {6, 7, 5}, {6, 8, 10},
        {7, 0, 25}, {7, 1, 18}, {7, 2, 22}, {7, 3, 25}, {7, 4, 20}, {7, 5, 15}, {7, 6, 5}, {7, 8, 8},
        {8, 0, 18}, {8, 1, 10}, {8, 2, 20}, {8, 3, 30}, {8, 4, 18}, {8, 5, 18}, {8, 6, 10}, {8, 7, 8}
    };

    // Select the source node (e.g., W1 = 0, W2 = 1, D1 = 2, D2 = 3, R1 = 4, R2 = 5, etc.)
    int sourceNode = 0;  // Let's assume we start from W1 (Node 0)

    // Run the Bellman-Ford algorithm
    bellmanFord(edges, V, E, sourceNode);

    return 0;
}
 </pre>
</div>

<script>
    function showCode() {
        // Display the code when the button is clicked
        document.getElementById('codeSection').style.display = 'block';
    }
</script>
    <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Line Space Example</title>
</head>
<body>



<br><br><br><br> <!-- 4 line breaks -->



</body>
</html>


</body>
</html>
